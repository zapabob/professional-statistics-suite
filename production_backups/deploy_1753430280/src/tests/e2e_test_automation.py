#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
E2E Test Automation System
E2E„ÉÜ„Çπ„ÉàËá™ÂãïÂåñ„Ç∑„Çπ„ÉÜ„É†

Author: Ryo Minegishi
Email: r.minegishi1987@gmail.com
License: MIT
"""

import sys
import os
import time
import json
import pickle
import signal
import threading
import asyncio
import tempfile
import shutil
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Any, Optional, Callable
import logging
import traceback

# GUIÈñ¢ÈÄ£
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import pandas as pd
import numpy as np

# „ÉÜ„Çπ„ÉàÈñ¢ÈÄ£
try:
    from playwright.async_api import async_playwright, Page, Browser, BrowserContext
    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False
    print("‚ö†Ô∏è Playwright not available. Install with: pip install playwright")

# „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂõ∫Êúâ„ÅÆ„Ç§„É≥„Éù„Éº„Éà
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from src.core.config import SPSSGradeConfig
from src.gui.professional_statistics_gui import ProfessionalStatisticsGUI
from src.gui.unified_ai_landing_gui import UnifiedAILandingGUI
from src.gui.kiro_integrated_gui import KiroIntegratedGUI

class CheckpointManager:
    """Ëá™Âãï„ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà‰øùÂ≠ò„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self, checkpoint_dir: str = "checkpoints"):
        self.checkpoint_dir = Path(checkpoint_dir)
        self.checkpoint_dir.mkdir(exist_ok=True)
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.backup_dir = self.checkpoint_dir / "backups"
        self.backup_dir.mkdir(exist_ok=True)
        self.max_backups = 10
        self.checkpoint_interval = 300  # 5ÂàÜÈñìÈöî
        self.last_checkpoint = time.time()
        self.running = True
        
        # „Ç∑„Ç∞„Éä„É´„Éè„É≥„Éâ„É©„ÉºË®≠ÂÆö
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        if hasattr(signal, 'SIGBREAK'):
            signal.signal(signal.SIGBREAK, self._signal_handler)
        
        # ÂÆöÊúü‰øùÂ≠ò„Çπ„É¨„ÉÉ„ÉâÈñãÂßã
        self.checkpoint_thread = threading.Thread(target=self._periodic_checkpoint, daemon=True)
        self.checkpoint_thread.start()
    
    def _signal_handler(self, signum, frame):
        """„Ç∑„Ç∞„Éä„É´„Éè„É≥„Éâ„É©„Éº: Á∑äÊÄ•‰øùÂ≠ò"""
        print(f"\nüõ°Ô∏è Á∑äÊÄ•‰øùÂ≠òÈñãÂßã („Ç∑„Ç∞„Éä„É´: {signum})")
        self.emergency_save()
        sys.exit(0)
    
    def _periodic_checkpoint(self):
        """ÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà‰øùÂ≠ò"""
        while self.running:
            try:
                current_time = time.time()
                if current_time - self.last_checkpoint >= self.checkpoint_interval:
                    self.save_checkpoint("periodic")
                    self.last_checkpoint = current_time
                time.sleep(10)  # 10ÁßíÈñìÈöî„Åß„ÉÅ„Çß„ÉÉ„ÇØ
            except Exception as e:
                print(f"‚ö†Ô∏è ÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà„Ç®„É©„Éº: {e}")
    
    def save_checkpoint(self, checkpoint_type: str = "manual"):
        """„ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà‰øùÂ≠ò"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            checkpoint_data = {
                "session_id": self.session_id,
                "timestamp": timestamp,
                "checkpoint_type": checkpoint_type,
                "test_state": self._get_current_state(),
                "metadata": {
                    "python_version": sys.version,
                    "platform": sys.platform,
                    "working_directory": os.getcwd()
                }
            }
            
            # JSON‰øùÂ≠ò
            json_file = self.checkpoint_dir / f"checkpoint_{self.session_id}_{timestamp}.json"
            with open(json_file, 'w', encoding='utf-8') as f:
                json.dump(checkpoint_data, f, ensure_ascii=False, indent=2)
            
            # Pickle‰øùÂ≠òÔºà„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁä∂ÊÖãÔºâ
            pickle_file = self.checkpoint_dir / f"checkpoint_{self.session_id}_{timestamp}.pkl"
            with open(pickle_file, 'wb') as f:
                pickle.dump(checkpoint_data, f)
            
            # „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÁÆ°ÁêÜ
            self._manage_backups()
            
            print(f"‚úÖ „ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà‰øùÂ≠òÂÆå‰∫Ü: {checkpoint_type} - {timestamp}")
            return True
            
        except Exception as e:
            print(f"‚ùå „ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà‰øùÂ≠òÂ§±Êïó: {e}")
            return False
    
    def emergency_save(self):
        """Á∑äÊÄ•‰øùÂ≠ò"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            emergency_data = {
                "session_id": self.session_id,
                "timestamp": timestamp,
                "checkpoint_type": "emergency",
                "test_state": self._get_current_state(),
                "error_info": {
                    "traceback": traceback.format_exc(),
                    "memory_usage": self._get_memory_usage()
                }
            }
            
            # Á∑äÊÄ•‰øùÂ≠ò„Éï„Ç°„Ç§„É´
            emergency_file = self.checkpoint_dir / f"emergency_{self.session_id}_{timestamp}.json"
            with open(emergency_file, 'w', encoding='utf-8') as f:
                json.dump(emergency_data, f, ensure_ascii=False, indent=2)
            
            print(f"üõ°Ô∏è Á∑äÊÄ•‰øùÂ≠òÂÆå‰∫Ü: {emergency_file}")
            return True
            
        except Exception as e:
            print(f"‚ùå Á∑äÊÄ•‰øùÂ≠òÂ§±Êïó: {e}")
            return False
    
    def load_checkpoint(self, checkpoint_file: str) -> Optional[Dict]:
        """„ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„ÉàË™≠„ÅøËæº„Åø"""
        try:
            checkpoint_path = self.checkpoint_dir / checkpoint_file
            if checkpoint_path.exists():
                with open(checkpoint_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            return None
        except Exception as e:
            print(f"‚ùå „ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„ÉàË™≠„ÅøËæº„ÅøÂ§±Êïó: {e}")
            return None
    
    def _get_current_state(self) -> Dict:
        """ÁèæÂú®„ÅÆÁä∂ÊÖãÂèñÂæó"""
        return {
            "timestamp": datetime.now().isoformat(),
            "active_tests": getattr(self, 'active_tests', []),
            "test_results": getattr(self, 'test_results', {}),
            "gui_state": getattr(self, 'gui_state', {}),
            "memory_usage": self._get_memory_usage()
        }
    
    def _get_memory_usage(self) -> Dict:
        """„É°„É¢„É™‰ΩøÁî®ÈáèÂèñÂæó"""
        try:
            import psutil
            process = psutil.Process()
            memory_info = process.memory_info()
            return {
                "rss": memory_info.rss,
                "vms": memory_info.vms,
                "percent": process.memory_percent()
            }
        except ImportError:
            return {"error": "psutil not available"}
    
    def _manage_backups(self):
        """„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÁÆ°ÁêÜ"""
        try:
            # Âè§„ÅÑ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÇíÂâäÈô§
            backup_files = list(self.backup_dir.glob("*.json"))
            if len(backup_files) > self.max_backups:
                backup_files.sort(key=lambda x: x.stat().st_mtime)
                for old_file in backup_files[:-self.max_backups]:
                    old_file.unlink()
                    print(f"üóëÔ∏è Âè§„ÅÑ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂâäÈô§: {old_file.name}")
        except Exception as e:
            print(f"‚ö†Ô∏è „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÁÆ°ÁêÜ„Ç®„É©„Éº: {e}")
    
    def cleanup(self):
        """„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó"""
        self.running = False
        if hasattr(self, 'checkpoint_thread'):
            self.checkpoint_thread.join(timeout=5)

class E2ETestAutomation:
    """E2E„ÉÜ„Çπ„ÉàËá™ÂãïÂåñ„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self, config: Optional[SPSSGradeConfig] = None):
        self.config = config or SPSSGradeConfig()
        self.checkpoint_manager = CheckpointManager()
        self.test_results = {}
        self.gui_instances = {}
        self.browser = None
        self.page = None
        self.test_log = []
        
        # „É≠„Ç∞Ë®≠ÂÆö
        self._setup_logging()
        
        # „ÉÜ„Çπ„Éà„Éá„Éº„Çø
        self.test_data = self._create_test_data()
    
    def _setup_logging(self):
        """„É≠„Ç∞Ë®≠ÂÆö"""
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / f"e2e_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _create_test_data(self) -> Dict[str, pd.DataFrame]:
        """„ÉÜ„Çπ„Éà„Éá„Éº„Çø‰ΩúÊàê"""
        return {
            "basic": pd.DataFrame({
                'group': ['A', 'A', 'B', 'B', 'C', 'C'],
                'score': [85, 90, 78, 82, 88, 92],
                'age': [25, 30, 28, 35, 22, 27]
            }),
            "regression": pd.DataFrame({
                'x': np.random.normal(0, 1, 100),
                'y': np.random.normal(0, 1, 100),
                'category': np.random.choice(['A', 'B', 'C'], 100)
            }),
            "timeseries": pd.DataFrame({
                'date': pd.date_range('2023-01-01', periods=100, freq='D'),
                'value': np.random.normal(100, 10, 100).cumsum()
            })
        }
    
    async def setup_browser(self):
        """„Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó"""
        if not PLAYWRIGHT_AVAILABLE:
            self.logger.warning("Playwright not available. Skipping browser tests.")
            return False
        
        try:
            self.playwright = await async_playwright().start()
            self.browser = await self.playwright.chromium.launch(
                headless=False,  # GUI„ÉÜ„Çπ„ÉàÁî®„Å´„Éò„ÉÉ„Éâ„É¨„ÇπÁÑ°Âäπ
                args=['--no-sandbox', '--disable-dev-shm-usage']
            )
            self.context = await self.browser.new_context()
            self.page = await self.context.new_page()
            
            self.logger.info("‚úÖ „Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÂ§±Êïó: {e}")
            return False
    
    async def cleanup_browser(self):
        """„Éñ„É©„Ç¶„Ç∂„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó"""
        try:
            if self.page:
                await self.page.close()
            if self.context:
                await self.context.close()
            if self.browser:
                await self.browser.close()
            if hasattr(self, 'playwright'):
                await self.playwright.stop()
            
            self.logger.info("‚úÖ „Éñ„É©„Ç¶„Ç∂„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü")
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éñ„É©„Ç¶„Ç∂„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂ§±Êïó: {e}")
    
    def test_gui_button_functionality(self, gui_class, test_name: str):
        """GUI„Éú„Çø„É≥Ê©üËÉΩ„ÉÜ„Çπ„Éà"""
        self.logger.info(f"üß™ GUI„Éú„Çø„É≥„ÉÜ„Çπ„ÉàÈñãÂßã: {test_name}")
        
        try:
            # GUI„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàê
            root = tk.Tk()
            root.withdraw()  # „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂÆüË°å
            
            gui_instance = gui_class(root)
            self.gui_instances[test_name] = gui_instance
            
            # „Éú„Çø„É≥Ë¶ÅÁ¥†„ÅÆÂèñÂæó„Å®„ÉÜ„Çπ„Éà
            buttons = self._find_buttons(gui_instance)
            
            test_results = {
                "total_buttons": len(buttons),
                "tested_buttons": 0,
                "successful_clicks": 0,
                "failed_clicks": 0,
                "button_details": []
            }
            
            for button_name, button_widget in buttons.items():
                try:
                    # „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ„ÉÜ„Çπ„Éà
                    button_widget.invoke()
                    test_results["successful_clicks"] += 1
                    test_results["button_details"].append({
                        "name": button_name,
                        "status": "success",
                        "text": button_widget.cget("text") if hasattr(button_widget, 'cget') else "N/A"
                    })
                    
                except Exception as e:
                    test_results["failed_clicks"] += 1
                    test_results["button_details"].append({
                        "name": button_name,
                        "status": "failed",
                        "error": str(e)
                    })
                
                test_results["tested_buttons"] += 1
            
            # ÁµêÊûúË®òÈå≤
            self.test_results[test_name] = test_results
            self.logger.info(f"‚úÖ {test_name} „Éú„Çø„É≥„ÉÜ„Çπ„ÉàÂÆå‰∫Ü: {test_results['successful_clicks']}/{test_results['tested_buttons']} ÊàêÂäü")
            
            # „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            root.destroy()
            return test_results
            
        except Exception as e:
            self.logger.error(f"‚ùå {test_name} „Éú„Çø„É≥„ÉÜ„Çπ„ÉàÂ§±Êïó: {e}")
            return {"error": str(e)}
    
    def _find_buttons(self, widget) -> Dict[str, tk.Widget]:
        """„Ç¶„Ç£„Ç∏„Çß„ÉÉ„ÉàÂÜÖ„ÅÆ„Éú„Çø„É≥„ÇíÂÜçÂ∏∞ÁöÑ„Å´Ê§úÁ¥¢"""
        buttons = {}
        
        def search_buttons(w):
            if isinstance(w, (tk.Button, ttk.Button)):
                button_name = w.cget("text") if hasattr(w, 'cget') else str(w)
                buttons[button_name] = w
            
            # Â≠ê„Ç¶„Ç£„Ç∏„Çß„ÉÉ„Éà„ÇíÂÜçÂ∏∞ÁöÑ„Å´Ê§úÁ¥¢
            for child in w.winfo_children():
                search_buttons(child)
        
        search_buttons(widget)
        return buttons
    
    async def test_web_interface(self, url: str, test_name: str):
        """Web„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÉÜ„Çπ„Éà"""
        if not self.page:
            self.logger.error("‚ùå „Éñ„É©„Ç¶„Ç∂„Åå„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
            return False
        
        self.logger.info(f"üß™ Web„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÉÜ„Çπ„ÉàÈñãÂßã: {test_name}")
        
        try:
            # „Éö„Éº„Ç∏Ë™≠„ÅøËæº„Åø
            await self.page.goto(url)
            await self.page.wait_for_load_state('networkidle')
            
            # „Éú„Çø„É≥Ë¶ÅÁ¥†„ÅÆÊ§úÁ¥¢„Å®„ÉÜ„Çπ„Éà
            buttons = await self.page.query_selector_all('button, input[type="button"], input[type="submit"]')
            
            test_results = {
                "total_buttons": len(buttons),
                "tested_buttons": 0,
                "successful_clicks": 0,
                "failed_clicks": 0,
                "button_details": []
            }
            
            for i, button in enumerate(buttons):
                try:
                    # „Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„ÉàÂèñÂæó
                    button_text = await button.text_content() or f"Button_{i}"
                    
                    # „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ„ÉÜ„Çπ„Éà
                    await button.click()
                    await self.page.wait_for_timeout(1000)  # 1ÁßíÂæÖÊ©ü
                    
                    test_results["successful_clicks"] += 1
                    test_results["button_details"].append({
                        "index": i,
                        "text": button_text,
                        "status": "success"
                    })
                    
                except Exception as e:
                    test_results["failed_clicks"] += 1
                    test_results["button_details"].append({
                        "index": i,
                        "text": button_text if 'button_text' in locals() else f"Button_{i}",
                        "status": "failed",
                        "error": str(e)
                    })
                
                test_results["tested_buttons"] += 1
            
            # „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà‰øùÂ≠ò
            screenshot_path = f"test_screenshots/{test_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
            os.makedirs("test_screenshots", exist_ok=True)
            await self.page.screenshot(path=screenshot_path)
            
            self.test_results[test_name] = test_results
            self.logger.info(f"‚úÖ {test_name} Web„ÉÜ„Çπ„ÉàÂÆå‰∫Ü: {test_results['successful_clicks']}/{test_results['tested_buttons']} ÊàêÂäü")
            
            return test_results
            
        except Exception as e:
            self.logger.error(f"‚ùå {test_name} Web„ÉÜ„Çπ„ÉàÂ§±Êïó: {e}")
            return {"error": str(e)}
    
    def test_data_processing_pipeline(self, test_name: str):
        """„Éá„Éº„ÇøÂá¶ÁêÜ„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„Éà"""
        self.logger.info(f"üß™ „Éá„Éº„ÇøÂá¶ÁêÜ„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„ÉàÈñãÂßã: {test_name}")
        
        try:
            test_data = self.test_data["basic"].copy()
            
            # „Éá„Éº„ÇøÂâçÂá¶ÁêÜ„ÉÜ„Çπ„Éà
            from data.data_preprocessing import DataPreprocessor
            preprocessor = DataPreprocessor()
            
            # Ê¨†ÊêçÂÄ§Âá¶ÁêÜ
            processed_data = preprocessor.handle_missing_values(test_data)
            
            # Â§ñ„ÇåÂÄ§Ê§úÂá∫
            outliers = preprocessor.detect_outliers(processed_data)
            
            # Áµ±Ë®àÂàÜÊûê
            from statistics.advanced_statistics import AdvancedStatistics
            stats = AdvancedStatistics()
            basic_stats = stats.calculate_basic_statistics(processed_data)
            
            test_results = {
                "original_size": test_data.shape,
                "processed_size": processed_data.shape,
                "outliers_detected": len(outliers),
                "basic_stats_calculated": len(basic_stats),
                "pipeline_status": "success"
            }
            
            self.test_results[test_name] = test_results
            self.logger.info(f"‚úÖ {test_name} „Éá„Éº„ÇøÂá¶ÁêÜ„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„ÉàÂÆå‰∫Ü")
            
            return test_results
            
        except Exception as e:
            self.logger.error(f"‚ùå {test_name} „Éá„Éº„ÇøÂá¶ÁêÜ„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„ÉàÂ§±Êïó: {e}")
            return {"error": str(e)}
    
    async def test_ai_integration_pipeline(self, test_name: str):
        """AIÁµ±Âêà„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„Éà"""
        self.logger.info(f"üß™ AIÁµ±Âêà„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„ÉàÈñãÂßã: {test_name}")
        
        try:
            from ai.ai_integration import AIOrchestrator
            
            # AI„Ç™„Éº„Ç±„Çπ„Éà„É¨„Éº„Çø„ÉºÂàùÊúüÂåñ
            orchestrator = AIOrchestrator()
            
            # „ÉÜ„Çπ„Éà„ÇØ„Ç®„É™
            test_query = "„Åì„ÅÆ„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆÂü∫Êú¨Áµ±Ë®à„ÇíË®àÁÆó„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
            test_data = self.test_data["basic"]
            
            # AIÂàÜÊûêÂÆüË°åÔºàAnalysisContext„Çí‰ΩúÊàê„Åó„Å¶process_user_query„Çí‰ΩøÁî®Ôºâ
            from src.ai.ai_integration import AnalysisContext
            context = AnalysisContext(
                user_id="test_user",
                session_id="test_session",
                data_fingerprint="test_data",
                analysis_history=[]
            )
            result = await orchestrator.process_user_query(test_query, context, test_data)
            
            test_results = {
                "query_processed": True,
                "ai_response_received": result is not None,
                "response_length": len(str(result)) if result else 0,
                "pipeline_status": "success"
            }
            
            self.test_results[test_name] = test_results
            self.logger.info(f"‚úÖ {test_name} AIÁµ±Âêà„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„ÉàÂÆå‰∫Ü")
            
            return test_results
            
        except Exception as e:
            self.logger.error(f"‚ùå {test_name} AIÁµ±Âêà„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„ÉàÂ§±Êïó: {e}")
            return {"error": str(e)}
    
    async def run_comprehensive_e2e_test(self):
        """ÂåÖÊã¨ÁöÑ„Å™E2E„ÉÜ„Çπ„ÉàÂÆüË°å"""
        self.logger.info("üöÄ ÂåÖÊã¨ÁöÑ„Å™E2E„ÉÜ„Çπ„ÉàÈñãÂßã")
        
        start_time = time.time()
        
        try:
            # „Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
            browser_ready = await self.setup_browser()
            
            # GUI„Éú„Çø„É≥„ÉÜ„Çπ„Éà
            gui_tests = [
                (ProfessionalStatisticsGUI, "ProfessionalStatisticsGUI_Buttons"),
                (UnifiedAILandingGUI, "UnifiedAILandingGUI_Buttons"),
                (KiroIntegratedGUI, "KiroIntegratedGUI_Buttons")
            ]
            
            for gui_class, test_name in gui_tests:
                self.test_gui_button_functionality(gui_class, test_name)
                self.checkpoint_manager.save_checkpoint(f"gui_test_{test_name}")
            
            # Web„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÉÜ„Çπ„ÉàÔºà„É≠„Éº„Ç´„É´„Çµ„Éº„Éê„Éº„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            if browser_ready:
                await self.test_web_interface("http://localhost:8000", "LocalWebInterface")
                self.checkpoint_manager.save_checkpoint("web_interface_test")
            
            # „Éá„Éº„ÇøÂá¶ÁêÜ„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„Éà
            self.test_data_processing_pipeline("DataProcessingPipeline")
            self.checkpoint_manager.save_checkpoint("data_pipeline_test")
            
            # AIÁµ±Âêà„Éë„Ç§„Éó„É©„Ç§„É≥„ÉÜ„Çπ„Éà
            await self.test_ai_integration_pipeline("AIIntegrationPipeline")
            self.checkpoint_manager.save_checkpoint("ai_pipeline_test")
            
            # „Éñ„É©„Ç¶„Ç∂„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            if browser_ready:
                await self.cleanup_browser()
            
            # ÊúÄÁµÇÁµêÊûúÈõÜË®à
            total_tests = len(self.test_results)
            successful_tests = sum(1 for result in self.test_results.values() if "error" not in result)
            
            end_time = time.time()
            duration = end_time - start_time
            
            final_results = {
                "total_tests": total_tests,
                "successful_tests": successful_tests,
                "failed_tests": total_tests - successful_tests,
                "success_rate": (successful_tests / total_tests * 100) if total_tests > 0 else 0,
                "duration_seconds": duration,
                "test_details": self.test_results
            }
            
            # ÁµêÊûú‰øùÂ≠ò
            self._save_test_results(final_results)
            
            self.logger.info(f"‚úÖ E2E„ÉÜ„Çπ„ÉàÂÆå‰∫Ü: {successful_tests}/{total_tests} ÊàêÂäü ({final_results['success_rate']:.1f}%)")
            return final_results
            
        except Exception as e:
            self.logger.error(f"‚ùå E2E„ÉÜ„Çπ„ÉàÂ§±Êïó: {e}")
            self.checkpoint_manager.emergency_save()
            return {"error": str(e)}
    
    def _save_test_results(self, results: Dict):
        """„ÉÜ„Çπ„ÉàÁµêÊûú‰øùÂ≠ò"""
        try:
            results_dir = Path("test_results")
            results_dir.mkdir(exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            results_file = results_dir / f"e2e_test_results_{timestamp}.json"
            
            with open(results_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, ensure_ascii=False, indent=2)
            
            self.logger.info(f"‚úÖ „ÉÜ„Çπ„ÉàÁµêÊûú‰øùÂ≠ò: {results_file}")
            
        except Exception as e:
            self.logger.error(f"‚ùå „ÉÜ„Çπ„ÉàÁµêÊûú‰øùÂ≠òÂ§±Êïó: {e}")
    
    def cleanup(self):
        """„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó"""
        try:
            self.checkpoint_manager.cleanup()
            
            # GUI„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            for gui_instance in self.gui_instances.values():
                if hasattr(gui_instance, 'destroy'):
                    gui_instance.destroy()
            
            self.logger.info("‚úÖ E2E„ÉÜ„Çπ„ÉàËá™ÂãïÂåñ„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü")
            
        except Exception as e:
            self.logger.error(f"‚ùå „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂ§±Êïó: {e}")

def main():
    """„É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞"""
    print("üöÄ E2E„ÉÜ„Çπ„ÉàËá™ÂãïÂåñ„Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï")
    
    # „ÉÜ„Çπ„ÉàËá™ÂãïÂåñ„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
    e2e_tester = E2ETestAutomation()
    
    try:
        # ÂåÖÊã¨ÁöÑ„Å™E2E„ÉÜ„Çπ„ÉàÂÆüË°å
        results = asyncio.run(e2e_tester.run_comprehensive_e2e_test())
        
        # ÁµêÊûúË°®Á§∫
        print("\n" + "="*50)
        print("üìä E2E„ÉÜ„Çπ„ÉàÁµêÊûú„Çµ„Éû„É™„Éº")
        print("="*50)
        
        if "error" in results:
            print(f"‚ùå „ÉÜ„Çπ„ÉàÂÆüË°å„Ç®„É©„Éº: {results['error']}")
        else:
            print(f"‚úÖ Á∑è„ÉÜ„Çπ„ÉàÊï∞: {results['total_tests']}")
            print(f"‚úÖ ÊàêÂäü„ÉÜ„Çπ„ÉàÊï∞: {results['successful_tests']}")
            print(f"‚ùå Â§±Êïó„ÉÜ„Çπ„ÉàÊï∞: {results['failed_tests']}")
            print(f"üìà ÊàêÂäüÁéá: {results['success_rate']:.1f}%")
            print(f"‚è±Ô∏è ÂÆüË°åÊôÇÈñì: {results['duration_seconds']:.2f}Áßí")
            
            # Ë©≥Á¥∞ÁµêÊûú
            print("\nüìã Ë©≥Á¥∞ÁµêÊûú:")
            for test_name, test_result in results['test_details'].items():
                if "error" in test_result:
                    print(f"  ‚ùå {test_name}: {test_result['error']}")
                else:
                    print(f"  ‚úÖ {test_name}: ÊàêÂäü")
        
        print("="*50)
        
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è „É¶„Éº„Ç∂„Éº„Å´„Çà„Çã‰∏≠Êñ≠")
        e2e_tester.checkpoint_manager.emergency_save()
        
    except Exception as e:
        print(f"\n‚ùå ‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº: {e}")
        e2e_tester.checkpoint_manager.emergency_save()
        
    finally:
        e2e_tester.cleanup()

if __name__ == "__main__":
    main() 